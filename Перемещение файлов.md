[<К содержанию](./%D0%9F%D1%80%D0%BE%D1%87%D1%82%D0%B8.md)

# Перемещение файлов

В отличие от многих других *VCS*, *Git* явно не отслеживает перемещение файла. Если переименовывать файл в *Git*, в *Git* не сохраняются метаданные, сообщающие ему, что переименовали файл. Однако *Git* довольно умен в том, чтобы выяснить это постфактум.

Таким образом, немного сбивает с толку тот факт, что в *Git* есть `mv` команда. Если хотите переименовать файл в *Git*, можно запустить что-то вроде:

```bush=
$ git mv file_from file_to
```

и это работает нормально. На самом деле, если запустите что-то вроде этого и посмотрите на статус, можно увидеть, что *Git* считает его переименованным файлом:

```bush=
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
```

Однако это эквивалентно запуску чего-то подобного:

```bush=
$ mv README.md README
$ git rm README.md
$ git add README
```

*Git* определяет, что это переименование неявно, поэтому не имеет значения, переименовывался ли файл таким образом или с помощью `mv` команды. Единственное реальное отличие заключается в том, что `git mv` используется одна команда вместо трех — это удобная функция. Что еще более важно, можно использовать любой инструмент, который нравится, для переименования файла и обратиться к `add/rm` позже, перед фиксацией.